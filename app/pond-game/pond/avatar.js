import * as Utils from '../utils/utils';
import * as Battle from './battle';
import * as Pond from './pond';
import Interpreter from 'js-interpreter';

export default class Avatar {
    /** Class for a avatar (duck).
     * @param {string} name Avatar's name.
     * @param {} startLoc Avatar's start position.
     */
    constructor(id, name, startLoc, colour, damageCallback) {
        /** ID of the duck. */
        this.id = id;
        /** Name of the duck. */
        this.name = name;
        /** Location of the duck in the field .*/
        this.loc = { ...startLoc };
        /** Color of the duck. */
        this.colour = colour;
        /** Duck's starting position. */
        this.startLoc = startLoc;
        /** Callback function called when the avatar is damaged. */
        this.damageCallback = damageCallback;
        /** Facing angle. */
        this.facing = Utils.math.getAngleDeg(50 - startLoc.x, 50 - startLoc.y);
        /** Swimming angle in degrees. */
        this.degree = 0;
        /** Whether this duck is dead or not. */
        this.dead = false;
        /** Duck's taken damage. */
        this.damage = 0;
        /** Duck's actual speed. */
        this.speed = 0;
        /** Duck's target speed. */
        this.desiredSpeed = 0;
        /** Date of last missile. */
        this.lastMissile = 0;
        /** Has the game started. */
        this.started = false;
        /** Interpreter instance. */
        this.interpreter = 0;
        // Push the avatar to the battle.
        this.visualizationIndex = Pond.avatars.length;
    }

    toString() {
        return `[${this.name}]`
    }

    /**
     * Reset the avatar.
     */
    reset() {
        this.dead = false;
        this.started = false;
        this.loc = { ...this.startLoc };
        this.facing = Utils.math.getAngleDeg(50 - this.loc.x, 50 - this.loc.y);
        this.speed = 0;
        this.desiredSpeed = this.speed;
        this.damage = 0;
        this.lastMissile = 0;
    }

    /**
     * Set the avatar's code.
     * @param {string|undefined} js JavaScript source which haven't yet transpiled, or undefined if no JS.
     * @param {string} compiled Executable ES5 code, generated by Babel.
     */
    setCode(js, compiled) {
        this.js = js;
        this.compiled = compiled;
    }

    /**
     * Initialize the interpreter.
     */
    initInterpreter() {
        this.interpreter = new Interpreter(this.compiled, Battle.initInterpreter);
    }

    /**
     * Add a damage to the avatar.
     * @param {number} damage Amount of damage to give.
     */
    addDamage(damage) {
        this.damage += damage;
        if (this.damage >= 100) {
            this.die();
        }
        this.damageCallback();
    }

    /**
     * Kill the duck immidiately.
     */
    die() {
        this.speed = 0;
        this.desiredSpeed = this.speed;
        this.dead = true;
        this.damage = 100;
        this.damageCallback();
    }

    /**
     * Scan in the specific angle with the specific resolution.
     * @param {number} degree Scan in this direction in degrees (0-360).
     * @param {number} opt_resolution Sensing resolution, 1 to 20 degrees. Defaults to 5.
     * @returns {number} Distance (0 - ~141), or Infinity if no avatar detected.
     */
    scan(degree, opt_resolution = 5) {
        if ((typeof degree !== 'number') || isNaN(degree) ||
            (typeof opt_resolution !== 'number') || isNaN(opt_resolution)) {
            throw TypeError();
        }
        let resolution;
        // Normalize the angle.
        degree = Utils.math.normalizeAngle(degree);
        // Clamp the resolution.
        resolution = Utils.math.clamp(opt_resolution, 0, 20);
        // Visualize the scan ray.
        Battle.events.push({
            'type': 'SCAN',
            'avatar': this,
            'degree': degree,
            'resolution': resolution
        });
        // Compute both edges of the scan.
        const scan1 = Utils.math.normalizeAngle(degree - resolution / 2);
        let scan2 = Utils.math.normalizeAngle(degree + resolution / 2);
        if (scan1 > scan2) {
            scan2 += 360;
        }
        const locX = this.loc.x;
        const locY = this.loc.y;
        // Check every enemy for existence in the scan beam.
        let closest = Infinity;
        for (const enemy of Pond.avatars) {
            // Continue if the enemy is same as this or enemy is dead.
            if (enemy === this || enemy.dead) continue;
            // Get the enemy's location.
            const ex = enemy.loc.x;
            const ey = enemy.loc.y;
            // Pythagorean theorem to find range to enemy's centre.
            const range = Utils.math.getDistance(locX, locY, ex, ey);
            // Check if the range is closer than closest.
            if (range >= closest) continue;
            // Compute angle between avatar and enemy's centre.
            let angle = Utils.math.getAngleDeg(ex - locX, ey - locY);
            angle = Utils.math.normalizeAngle(angle);
            // Raise the angle by 360 if needed (handles wrapping).
            if (angle < scan1) {
                angle += 360;
            }
            // Check if enemy is within scan edges.
            if (scan1 <= angle && angle <= scan2) {
                closest = range;
            }
        }
        // Return the closest enemy's distance.
        return closest;
    }

    /**
     * Start swimming.
     * @param {number} degree Heading of avatar in degrees (0-360).
     * @param {number} opt_speed Desired speed (0-100). 0 is the same as calling stop(). Defaults to 50.
     */
    drive(degree, opt_speed = 50) {
        // Throw an TypeError if degree or opt_speed isn't number
        if ((typeof degree !== 'number') || isNaN(degree) ||
            (typeof opt_speed !== 'number') || isNaN(opt_speed)) {
            throw TypeError();
        }
        // Normalize the angle.
        let desiredDegree = Utils.math.normalizeAngle(degree);
        if (this.degree !== desiredDegree) {
            if (this.speed <= 50) {
                // Changes in direction can be negotiated at speeds of less than 50%.
                this.degree = desiredDegree;
                this.facing = this.degree;
            } else {
                // Stop the avatar if an over-speed turn was commanded.
                opt_speed = 0;
            }
        }

        if (this.speed === 0 && opt_speed > 0) {
            // If starting, bump the speed immediately so that avatars can see a change.
            this.speed = 0.1;
        }
        // Clamp the speed.
        this.desiredSpeed = Utils.math.clamp(opt_speed, 0, 100);
    }

    /**
     * Shoot a cannon in the specific angle at the specific range.
     * @param {number} degree Heading of the cannon in degrees (0-360).
     * @param {number} range Distance to impact (0-70).
     * @returns {boolean} True if cannon fired, false if still reloading cannon.
     */
    cannon(degree, range) {
        if ((typeof degree !== 'number') || isNaN(degree) ||
            (typeof range !== 'number') || isNaN(range)) {
            throw TypeError;
        }
        // Get the now date.
        const now = Date.now();
        // Check if the missile is reloading.
        // 1s reload time -> 1
        if (this.lastMissile + Battle.reload_time * 1000 > now) {
            return false;
        }
        // Set the now date in order to check if the missile is reloading.
        this.lastMissile = now;
        const startLoc = this.loc;
        // Normalize the degree.
        degree = Utils.math.normalizeAngle(degree);
        // Face the shooting angle.
        this.facing = degree;
        // Clamp the range.
        range = Utils.math.clamp(range, 0, 70);
        // Get the cannon end location.
        const endLoc = Utils.math.getPosition(degree, range);
        endLoc.x += startLoc.x;
        endLoc.y += startLoc.y;
        // Push the missile to the battle.
        Battle.missiles.push({
            avatar: this,
            startLoc: startLoc,
            degree: degree,
            range: range,
            endLoc: endLoc,
            progress: 0
        });
        // Visuaize the bang effect.
        Battle.events.push({
            type: 'BANG',
            avatar: this,
            degree: degree
        });
        return true;
    }
}
